/*
================================================================================
CommentPress Core Common addComment Javascript
================================================================================
AUTHOR: Christian Wach <needle@haystack.co.uk>
--------------------------------------------------------------------------------
NOTES

This script is only included when a CommentPress Core compatible theme is active.

The moveForm() method is called by onclick attributes of the "Reply to this
comment" links, which are auto-generated by WP.

This is a rewritten version of the inbuilt WordPress addComment object for
several reasons:

(1) The built-in WordPress Javascript does not allow for the enabling of
TinyMCE, *even though* WordPress now ships with it built-in to the Admin
Interface. TinyMCE must be de-activated before the respond div is moved, then
re-enabled once the move has been completed.

(2) There is a name clash between TinyMCE's wrapper and the comment_parent input
when comment threading is enabled. Both use id="comment_parent", thus preventing
that variable from being posted when the form is submitted.

(3) CommentPress Core has a replytopara link parameter and an additional
text_signature variable which need to be accounted for. See the moveFormToPara()
method for details of the latter.

--------------------------------------------------------------------------------
*/



/**
 * Comment area handler object.
 *
 * @since 3.8
 */
addComment = {



	/**
	 * Method for moving the comment form.
	 *
	 * @since 3.8
	 *
	 * @param {String} commentID The CSS ID of the comment.
	 * @param {String} parentID The CSS ID of the parent comment.
	 * @param {String} respondID The CSS ID of the comment form.
	 * @param {String} postID The ID of the WordPress post.
	 * @param {String} textSig The target text signature.
	 * @return false
	 */
	moveForm : function( commentID, parentID, respondID, postID, textSig ) {

		// Unload tinyMCE.
		this.disableForm();

		// Properties.
		var div_e;
		var comm_e = this.I(commentID);
		var respond_e = this.I(respondID);
		var cancel_e = this.I('cancel-comment-reply-link');
		var parent_e = this.I('comment_parent');
		var post_e = this.I('comment_post_ID');
		// Get comment text signature item.
		if ( this.I('text_signature') ) {
			var sig_e = this.I('text_signature');
		} else {
			var sig_e = '';
		}

		// Sanity check.
		if ( !comm_e || !respond_e || !cancel_e || !parent_e ) {

			// Reload tinyMCE.
			this.enableForm();

			// --<
			return;

		}

		// Maybe reset from comment edit format.
		addComment.commentEditResetForm();

		// If we have them.
		if ( post_e && postID ) {

			// Set comment_post_ID hidden input to postID.
			post_e.value = postID;

		}

		// Set comment_parent hidden input to parentID.
		parent_e.value = parentID;

		// Set text_signature hidden input to text signature.
		if ( sig_e !== '' ) { sig_e.value = textSig; }

		// Store respondID for cancel method to access.
		this.respondID = respondID;

		// Set title.
		addComment.setTitle( parentID, textSig, 'set' );

		// Do we have a temp div?
		if ( !this.I('wp-temp-form-div') ) {

			// Create one.
			div_e = document.createElement('div');
			div_e.id = 'wp-temp-form-div';
			div_e.style.display = 'none';
			respond_e.parentNode.insertBefore( div_e, respond_e );

		}

		// Insert comment response area.
		comm_e.parentNode.insertBefore( respond_e, comm_e.nextSibling );

		// If not special page and we encouraging commenting and not a reply.
		if ( cp_special_page != '1' && cp_promote_reading == '0' && parentID == '0' ) {

			// Hide cancel link.
			cancel_e.style.display = 'none';

		} else {

			// Show cancel link.
			cancel_e.style.display = '';

		}

		/**
		 * Method for cancel button.
		 *
		 * @since 3.8
		 *
		 * @return {Boolean} false.
		 */
		cancel_e.onclick = function() {

			// --<
			return addComment.cancelForm();

		}

		// Test for tinyMCE.
		if ( cp_tinymce == '1' ) {

			// Reload tinyMCE.
			this.enableForm();

		} else {

			// Try and give focus to textarea - disabled since we use tinyMCE
			// except for on mobile devices, where we don't want to auto-focus.
			//try { this.I('comment').focus(); }
			//catch(e) {}

		}

		// Show respond element.
		respond_e.style.display = 'block';

		// Clear comment highlight.
		addComment.clearCommentHighlight( this.parentID );

		// Highlight.
		addComment.highlightComment( parentID );

		// Store text sig.
		this.text_signature = textSig;
		this.parentID = parentID;

		// Collapse params into a data array.
		var data = [ commentID, parentID, respondID, postID, textSig ];

		/**
		 * Broadcast that we're done and pass data.
		 *
		 * @since 3.9.12
		 *
		 * @param {String} An identifier.
		 * @param {Array} data The params passed in to this method.
		 */
		jQuery(document).trigger( 'commentpress-commentform-moved', [ 'add', data ] );

		// Do not bubble.
		return false;

	},



	/**
	 * Method for moving the comment form to a paragraph block.
	 *
	 * @since 3.8
	 *
	 * @param {String} paraNum The paragraph number.
	 * @param {String} textSig The target text signature.
	 * @param {String} postID The ID of the WordPress post.
	 * @return {Boolean} false
	 */
	moveFormToPara : function( paraNum, textSig, postID ) {

		// Set paraID.
		var paraID = 'reply_to_para-' + paraNum;

		// Move the form.
		addComment.moveForm(
			paraID,
			'0',
			'respond',
			postID,
			textSig
		);

		// Do not bubble.
		return false;

	},



	/**
	 * Method for moving the comment form for editing comments.
	 *
	 * @since 3.9.12
	 *
	 * @param {String} commentID The CSS ID of the comment.
	 * @param {String} parentID The CSS ID of the parent comment.
	 * @param {String} respondID The CSS ID of the comment form.
	 * @param {String} postID The ID of the WordPress post.
	 * @param {String} textSig The target text signature.
	 * @param {String} commentContent The content of the comment.
	 * @param {String} nonce The nonce for the form.
	 * @return false
	 */
	moveFormToEdit : function( commentID, parentID, respondID, postID, textSig, commentContent, nonce ) {

		// Unload tinyMCE.
		this.disableForm();

		// Properties.
		var div_e;
		var comm_e = this.I(commentID);
		var respond_e = this.I(respondID);
		var cancel_e = this.I('cancel-comment-reply-link');
		var parent_e = this.I('comment_parent');
		var post_e = this.I('comment_post_ID');
		// Get comment text signature item.
		if ( this.I('text_signature') ) {
			var sig_e = this.I('text_signature');
		} else {
			var sig_e = '';
		}

		// Sanity check.
		if ( !comm_e || !respond_e || !cancel_e || !parent_e ) {

			// Reload tinyMCE.
			this.enableForm();

			// --<
			return;

		}

		// Maybe reset from comment edit format.
		addComment.commentEditResetForm();

		// Store commentEditMode.
		this.commentEditMode = 'y';

		// Append an identifying input to the comment form.
		var input = '<input type="hidden" name="cp_edit_comment" id="cp_edit_comment" value="y" />';
		jQuery(input).appendTo( '#commentform' );

		// Append an input with the comment ID to the comment form.
		var comment_id_num = commentID.split('-')[1];
		var comment_id = '<input type="hidden" name="comment_ID" id="comment_ID" value="' + comment_id_num + '" />';
		jQuery(comment_id).appendTo( '#commentform' );

		// Append nonce to the comment form.
		var nonce = '<input type="hidden" name="cpajax_comment_nonce" id="cpajax_comment_nonce" value="' + nonce + '" />';
		jQuery(nonce).appendTo( '#commentform' );

		// Set comment_post_ID hidden input to postID if we have them.
		if ( post_e && postID ) {
			post_e.value = postID;
		}

		// Set comment_parent hidden input to parentID.
		parent_e.value = parentID;

		// Set text_signature hidden input to text signature.
		if ( sig_e !== '' ) {
			sig_e.value = textSig;
		}

		// Store respondID for cancel method to access.
		this.respondID = respondID;

		// Store previous content of form title.
		addComment.previousTitle = jQuery('#respond_title').text();

		// Alter content of form title.
		jQuery('#respond_title').text( CommentPress_Form.localisation['edit_title'] );

		// Show all comment content blocks.
		jQuery( '.comment-content' ).css( 'display', 'block' );

		// Hide this comment content.
		jQuery('#' + commentID + ' .comment-content').hide();

		// Store previous content of submit button.
		this.previousSubmit = jQuery('#submit').attr( 'value' );

		// Alter content of comment form submit button.
		jQuery('#submit').attr( 'value', CommentPress_Form.localisation['submit'] );

		// Insert content into unrendered comment form.
		jQuery('#comment').val( commentContent );

		// Do we have a temp div?
		if ( !this.I('wp-temp-form-div') ) {

			// Create one.
			div_e = document.createElement('div');
			div_e.id = 'wp-temp-form-div';
			div_e.style.display = 'none';
			respond_e.parentNode.insertBefore( div_e, respond_e );

		}

		// Insert comment response area.
		comm_e.parentNode.insertBefore( respond_e, comm_e.nextSibling );

		// If not special page and we encouraging commenting and not a reply.
		if ( cp_special_page != '1' && cp_promote_reading == '0' && parentID == '0' ) {

			// Hide cancel link.
			cancel_e.style.display = 'none';

		} else {

			// Show cancel link.
			cancel_e.style.display = '';

		}

		/**
		 * Method for cancel button.
		 *
		 * @since 3.9.12
		 *
		 * @return {Boolean} false.
		 */
		cancel_e.onclick = function() {

			// Unload tinyMCE.
			addComment.disableForm();

			// Maybe reset from comment edit format.
			addComment.commentEditResetForm();

			// --<
			return addComment.cancelForm();

		}

		// Test for tinyMCE.
		if ( cp_tinymce == '1' ) {

			// Reload tinyMCE.
			this.enableForm();

		} else {

			// Try and give focus to textarea - disabled since we use tinyMCE
			// except for on mobile devices, where we don't want to auto-focus.
			//try { this.I('comment').focus(); }
			//catch(e) {}

		}

		// Show respond element.
		respond_e.style.display = 'block';

		// Clear comment highlight.
		addComment.clearCommentHighlight( this.parentID );

		// Highlight.
		addComment.highlightComment( parentID );

		// Store text sig.
		this.text_signature = textSig;
		this.parentID = parentID;

		// Collapse params into a data array.
		var data = [ commentID, parentID, respondID, postID, textSig, commentContent ];

		/**
		 * Broadcast that we're done and pass data.
		 *
		 * @since 3.9.12
		 *
		 * @param {String} An identifier.
		 * @param {Array} data The params passed in to this method.
		 */
		jQuery(document).trigger( 'commentpress-commentform-moved', [ 'edit', data ] );

		// Do not bubble.
		return false;

	},



	/**
	 * Reset the response markup from comment edit form format.
	 *
	 * @since 3.9.12
	 */
	commentEditResetForm : function() {

		// Reset commentEditMode.
		this.commentEditMode = 'n';

		// Show all comment content blocks.
		jQuery('.comment-content').css( 'display', 'block' );

		// Clear comment form.
		jQuery('#comment').val( '' );

		// Alter content of comment form submit button.
		jQuery('#submit').attr( 'value', this.previousSubmit );

		// Alter content of form title.
		if ( 'undefined' !== typeof addComment.previousTitle && addComment.previousTitle != '' ) {
			jQuery('#respond_title').text( addComment.previousTitle );
		}

		// Remove identifying input from the comment form.
		jQuery('#cp_edit_comment').remove();

		// Remove comment ID input.
		jQuery('#comment_ID').remove();

		// Remove nonce input from the comment form.
		jQuery('#cpajax_comment_nonce').remove();

	},



	/**
	 * Reset the comment form.
	 *
	 * @since 3.8
	 *
	 * @return {Boolean} false
	 */
	cancelForm : function() {

		// Get our temp div element.
		var temp_e = addComment.I('wp-temp-form-div');

		// Get our comment response element.
		var respond_e = addComment.I(addComment.respondID);

		// Get cancel button.
		var cancel_e = this.I('cancel-comment-reply-link');

		// Sanity check.
		if ( !temp_e || !respond_e ) {

			// --<
			return;

		}

		// Clear comment highlight.
		addComment.clearCommentHighlight( this.parentID );

		// If not special page.
		if ( cp_special_page != '1' ) {

			// Init text_sig.
			var text_sig = '';
			var para_num = '';

			// If we have a text sig.
			if ( addComment.I('text_signature') ) {

				// Unset comment text signature value.
				text_sig = addComment.I('text_signature').value;
				addComment.I('text_signature').value = '';

				// This is a potential source of weakness: if the para text has been changed,
				// but not by much, then levenshtein will still associate the comment with
				// a paragraph, but there will be no *exact* reference in the DOM.

				// Find para num.
				var para_id = jQuery('#para_wrapper-' + text_sig + ' .reply_to_para').attr('id');

				// Is there an element for the exact match?
				if ( 'undefined' === typeof para_id ) {

					// NO -> crawl up the DOM looking for the wrapper.
					var parent_wrapper = jQuery('#respond').closest('div.paragraph_wrapper');

					// If we get it.
					if ( parent_wrapper.length > 0 ) {

						// Grab it's ID.
						var parent_wrapper_id = parent_wrapper.attr('id');

						// Proceed with this instead.
						var para_id = jQuery( '#' + parent_wrapper_id + ' .reply_to_para').attr('id');

					}

				}

				// Get paragraph number.
				para_num = para_id.split('-')[1];

			}

			// Are we encouraging reading?
			if ( cp_promote_reading == '1' ) {

				// Hide respond element.
				if ( respond_e.style.display != 'none' ) {
					respond_e.style.display = 'none';
				}

			} else {

				// Get comment post ID.
				var post_id = addComment.I('comment_post_ID').value;

				// Return form to para position.

				// Return form to para.
				addComment.moveFormToPara( para_num, text_sig, post_id );

				// Do not bubble.
				return false;

			}

		} else {

			//addComment.highlightComment( this.parentID );

		}

		// Unload tinyMCE.
		addComment.disableForm();

		// Get comment post ID.
		var parent_id = addComment.I('comment_parent').value;

		// Unset comment parent value.
		addComment.I('comment_parent').value = '0';

		// DOM manipulation.
		temp_e.parentNode.insertBefore( respond_e, temp_e );
		temp_e.parentNode.removeChild( temp_e );

		// Hide cancel link.
		cancel_e.style.display = 'none';

		// Disable this until next run.
		cancel_e.onclick = null;

		// Set title.
		addComment.setTitle( '0', text_sig, 'cancel' );

		// Clear text sig.
		this.text_signature = '';

		// Clear comment form.
		jQuery('#comment').val( '' );

		// Reload tinyMCE.
		addComment.enableForm();

		// Empty data array.
		var data = [];

		/**
		 * Broadcast that we're done and pass data.
		 *
		 * @since 3.9.12
		 *
		 * @param {String} An identifier.
		 * @param {Array} data The params passed in to this method.
		 */
		jQuery(document).trigger( 'commentpress-commentform-moved', [ 'cancel', data ] );

		// Do not bubble.
		return false;

	},



	/**
	 * Get element ID.
	 *
	 * @since 3.8
	 *
	 * @param {String} e The element to find.
	 * @return {Object} The DOM element's ID.
	 */
	I : function(e) {

		// --<
		return document.getElementById(e);

	},



	/**
	 * Enable the comment form.
	 *
	 * @since 3.8
	 */
	enableForm : function() {

		// Test for tinyMCE.
		if ( cp_tinymce == '1' ) {

			// Test for tinyMCE version.
			if ( cp_tinymce_version == '3' ) {

				// Load tinyMCE up to version 3.
				setTimeout( function() {
					tinyMCE.execCommand( 'mceAddControl', false, 'comment' );
					tinyMCE.execCommand( 'render' );
				}, 1 );

			} else {

				// Load tinyMCE version 4.
				setTimeout( function() {
					tinyMCE.execCommand( 'mceAddEditor', false, 'comment' );
					tinyMCE.execCommand( 'render' );
				}, 1 );

			}

		}

	},


	/**
	 * Disable the comment form.
	 *
	 * @since 3.8
	 */
	disableForm : function() {

		// Test for tinyMCE.
		if ( cp_tinymce == '1' ) {

			// Test for tinyMCE version.
			if ( cp_tinymce_version == '3' ) {

				// Unload tinyMCE up to version 3.
				tinyMCE.execCommand( 'mceRemoveControl', false, 'comment' );

			} else {

				// Unload tinyMCE version 4.
				tinyMCE.execCommand( 'mceRemoveEditor', false, 'comment' );

			}

		}

	},



	/**
	 * Set the comment form title.
	 *
	 * @since 3.8
	 *
	 * @param {String} parentID The CSS ID of the parent element.
	 * @param {String} textSig The text signature.
	 * @param {String} mode The mode (eg, 'cancel').
	 */
	setTitle : function( parentID, textSig, mode ) {

		// Get comment form title item.
		var title = addComment.I('respond_title');

		// Is it a comment reply?
		if ( 'undefined' === typeof parentID || parentID == '0' ) {

			// NO -> is it a comment on the whole page?
			if ( 'undefined' === typeof textSig || textSig == '' ) {

				// If special page.
				if ( cp_special_page == '1' ) {

					// Restore.
					title.innerHTML = CommentPress_Form.localisation['title'];

				} else {

					// Restore.
					title.innerHTML = jQuery( '#para_wrapper-' + textSig + ' a.reply_to_para' ).text();

					// Get comment list.
					var comment_list = jQuery( '#para_wrapper-' + addComment.text_signature + ' .commentlist' );

					// If we have a comment list.
					if ( comment_list[0] && cp_promote_reading == '0' ) {
						jQuery( '#para_wrapper-' + addComment.text_signature + ' div.reply_to_para' ).show();
					}

					// If we're cancelling, show all reply to links.
					if ( mode == 'cancel' && cp_promote_reading == '1' ) {
						jQuery( 'div.reply_to_para' ).show();
					} else {
						jQuery( '#para_wrapper-' + textSig + ' div.reply_to_para' ).hide();
					}

				}

			} else {

				// It's a comment on a paragraph.
				var reply_text = jQuery( '#para_wrapper-' + textSig + ' a.reply_to_para' );

				/*
				// Test for multiples.
				if ( reply_text.length > 1 ) {
					reply_text = jQuery( reply_text[0] );
				}
				*/

				//title.innerHTML = 'Comment on this paragraph';
				title.innerHTML = reply_text.text();

				// Get comment list.
				var comment_list = jQuery( '#para_wrapper-' + addComment.text_signature + ' .commentlist' );

				// If we have a comment list and promoting commenting - or promoting reading.
				if ( ( comment_list[0] && cp_promote_reading == '0' ) || cp_promote_reading == '1' ) {

					// Show previous reply to para link.
					if ( 'undefined' !== typeof addComment.text_signature ) {
						jQuery( '#para_wrapper-' + addComment.text_signature + ' div.reply_to_para' ).show();
					}

				}

				// Sort out reply to para links.
				if ( cp_promote_reading == '0' ) {
					jQuery( '#para_wrapper-' + textSig + ' div.reply_to_para' ).hide();
				} else {
					// If we're cancelling, show all reply to links.
					if ( mode == 'cancel' ) {
						jQuery( 'div.reply_to_para' ).show();
					} else {
						jQuery( '#para_wrapper-' + textSig + ' div.reply_to_para' ).toggle();
					}
				}

			}

		} else {

			// It's a reply to another comment.

			// Store.
			//addComment.replyTitle = title.innerHTML;

			// Seems like sometimes we can get an array for the .reply with more than one item.
			var reply = jQuery( '#comment-' + parentID + ' > .reply' )[0];

			// Get unique.
			var unique = jQuery(reply).text();

			// If we have link text, then a comment reply is allowed.
			if ( unique != '' ) {

				// Get reply link text.
				title.innerHTML = unique;

				// Sanitise textSig.
				if ( 'undefined' === typeof textSig || textSig == '' ) { textSig == ''; }

				// If promoting commenting, sort out reply to para links.
				if ( cp_promote_reading == '1' ) {

					// Show previous.
					if ( 'undefined' !== typeof addComment.text_signature ) {
						jQuery( '#para_wrapper-' + addComment.text_signature + ' div.reply_to_para' ).show();
					}

					// Show current.
					jQuery( '#para_wrapper-' + textSig + ' div.reply_to_para' ).show();

				}

			}

		}

	},



	/**
	 * Highlight a comment.
	 *
	 * @since 3.8
	 *
	 * @param {String} parentID The enclosing list item's CSS ID.
	 */
	highlightComment : function( parentID ) {

		// Hide this reply link.
		if ( parentID != '0' ) {
			jQuery( '#comment-' + parentID + ' > .reply' ).css('display', 'none');
		}

		// Trigger theme to highlight comment.
		jQuery( document ).trigger( 'commentpress-comment-highlight', [ parentID ] );

	},



	/**
	 * Clear a comment highlight.
	 *
	 * @since 3.8
	 *
	 * @param {Integer} parentID The enclosing list item's CSS ID.
	 */
	clearCommentHighlight : function( parentID ) {

		// Show this reply link.
		if ( parentID != '0' ) {

			// Show reply link.
			jQuery( '#comment-' + parentID + ' > .reply' ).css('display', 'block');

		}

		// Unhighlight comment.
		jQuery( document ).trigger( 'commentpress-comment-unhighlight', [ parentID ] );

	},



	/**
	 * Clear all comment highlights.
	 *
	 * @since 3.8
	 */
	clearAllCommentHighlights : function() {

		// Show all reply links.
		jQuery( '.reply' ).css('display', 'block');

		// Clear highlight.
		jQuery( document ).trigger( 'commentpress-comment-highlights-clear' );

	},



	/**
	 * Get stored text signature.
	 *
	 * @since 3.8
	 *
	 * @return {String} text_signature The text signature.
	 */
	getTextSig : function() {

		// --<
		return this.text_signature;

	},



	/**
	 * Find out if a comment is top level or not.
	 *
	 * @since 3.8
	 *
	 * @return {Boolean} True if comment is top level, false otherwise.
	 */
	getLevel : function() {

		// Is the comment on the paragraph?
		if ( 'undefined' === typeof this.parentID || this.parentID === '0' ) {
			return true;
		} else {
			return false;
		}

	}

}



